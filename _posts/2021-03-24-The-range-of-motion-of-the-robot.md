---
layout: post
title: 13. 机器人的运动范围
date: 2021-03-24
Author: 龙龙
categories: 
tags: [剑指offer]
comments: true
---

### 问题要求

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

**示例 1：**

```
输入：m = 2, n = 3, k = 1
输出：3
```

**示例 2：**

```
输入：m = 3, n = 1, k = 0
输出：1
```

**提示：**

- `1 <= n,m <= 100`
- `0 <= k <= 20`

### 解决思路

问题说的很简单，就是找从 (0, 0) -> (m-1, n-1) 这个矩阵中找到机器人能够进入的方格个数。机器人能够进入方格的要求是这个方格的行坐标和列坐标的数位之和不能大于 *k*， 比如当 *k = 18* 时机器人能够进入方格 [35, 37]，因为其数位和为 3 + 5 + 3 + 7 = 18，而不能进入方格 [35, 38]，因为数位和为 3 + 5 + 3 + 8 = 19 > 18。

在知道这道题啥意思之后，解题就很简单了。定义一个方法，**dfs(i, j, m, n, k, visited)**。这个方法中的参数分别为：

* i, j 表示当前遍历的位置
* m, n 表示矩阵的高度和长度
* k 表示临界值 
* visited 遍历的数组，如果visited[ i ] [ j ] = false，表示这个方格还没有遍历过，反之，则是遍历过了

### 代码实现

```java
class Solution {
    private int ans = 0;
    public int movingCount(int m, int n, int k) {
        // 定义一个数组来保存该节点是否被遍历过
        boolean[][] visited = new boolean[m][n];

        // 搜索
        dfs(0, 0, m, n, k, visited);

        // 返回结果
        return ans;
    }

    // i, j 表示当前遍历的位置
    // m, n 表示矩阵的高度和长度
    // k 表示临界值
    // visited 遍历的数组
    private void dfs(int i, int j, int m, int n, int k, boolean[][] visited) {
        // 特判：越界，或者 i 和 k 的数位和大于 k，或者(i, j)这个节点已经被遍历过
        if (i < 0 || i >= m || j < 0 || j >= n || (i % 10 + i / 10 + j % 10 + j / 10) > k || visited[i][j]) {
            return ;
        }
        // 已经遍历了该节点
        visited[i][j] = true;
        // 结果+1
        ans++;
        // 因为我们是从左上角往右下角遍历的，所以就不需要向上或者向左搜索啦
        // 往右和往下搜索
        dfs(i, j+1, m, n, k, visited);
        dfs(i+1, j, m, n, k, visited);
    }
}
```

貌似挺简单的，有了思路解决挺快的。